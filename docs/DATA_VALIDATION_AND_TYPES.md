# Data Validation & Type Safety Strategy

This document summarizes our architectural decision regarding data validation and type safety in the AI Accounting App.

## 1. Strategy Overview

We adopt a **Pragmatic Layered Approach** to balance developer velocity with application stability.

| Flow | Technology | Strategy |
| :--- | :--- | :--- |
| **Inbound** (User -> API -> DB) | **Zod** | Strict runtime validation for all form inputs and server action arguments. |
| **Outbound** (DB -> API -> UI) | **TypeScript (Supabase Generated)** | Compile-time safety using auto-generated types from the database schema. |

## 2. Inbound Validation: The "Zod Gatekeeper"

All data entering the system from the client must be parsed and validated using Zod schemas.

- **Why**: Prevents SQL injection (indirectly), malformed data, and ensures business logic constraints are met before hitting the database.
- **Implementation**: 
  - Define schemas in `lib/domain/models.ts`. (as defined in `TECH_DESIGN.md`)
  - Use `schema.safeParse()` in Server Actions.
  - Share schemas with the frontend for client-side form validation (e.g., via `zodResolver`).

## 3. Outbound Type Safety: "Trust the Schema"

For data reading, we rely on the types generated by the Supabase CLI (`database.types.ts`).

- **Why**: High developer velocity. We avoid manually maintaining hundreds of interfaces that mirror the database. Supabase's query builder automatically provides precise types for joined data.
- **Risk**: Tight coupling to the database schema. If a column is renamed in the DB, the generated types change, potentially breaking the UI.

## 4. Mitigating Breaking Changes & Upgrade Risks

To prevent "Tight Coupling" from making deployments difficult, we follow these practices:

### 4.1. Versioned Database Migrations
- Never make "hot-fixes" to the database schema in production.
- All changes must go through `supabase/migrations`.
- **Backward Compatibility**: If renaming a column, prefer adding a new column, migrating data, and then removing the old one in a subsequent release.

### 4.2. Staging Environment & Type Sync
- **Flow**: `Dev DB` -> `PR` -> `Staging DB` -> `Production DB`.
- Types are generated against the `Staging DB` before any production deployment.
- If the generated types cause TypeScript errors in the application, the build fails in CI/CD, preventing a broken deploy.

### 4.3. Mapper Functions (The Decoupling Point)
For mission-critical components, we use **Mappers** within the Storage layer (as defined in `TECH_DESIGN.md`).
- Even if we use Supabase types to fetch data, the storage layer maps that data into a **Domain Model**.
- **Example**: If `firm_id` changes to `tenant_id` in the DB, we only update the mapper:
  ```typescript
  // storage/supabase/profile.ts
  const mapper = (dbRow: DbProfile): DomainProfile => ({
    id: dbRow.id,
    firmId: dbRow.tenant_id, // Map new DB name back to stable App name
  });
  ```

### 4.4. Integration Testing
- Write tests that hit a local Supabase instance. If a schema change breaks the expected data shape, these tests will catch it before the types are even re-generated.

## 5. Summary Recommendation
- **Small/Fast Changes**: Use generated types directly in the UI for speed.
- **Stable/Core Entities**: Always use the **Storage Layer + Domain Models + Mappers** to protect the UI from database volatility.
- **Always**: Use Zod for any data coming from a `FormData` or `JSON` request body.

## 6. Final Decision: Service-First (Hybrid)

**Current Choice**: We prioritize **Velocity** (Speed) for Phase 1.

1.  **Reads (Data Fetching)**: 
    - **Server Components**: Call Supabase/Service Layer directly.
    - **Client Components**: Use **SWR** for state management, but use the **Supabase Client SDK** directly as the fetcher to avoid writing boilerplate API routes.
2.  **Writes (Mutations)**:
    - **Always** use Server Actions + Zod Validation. This is the non-negotiable security boundary.
3.  **Abstraction**:
    - We will NOT create separate Domain Models or Mappers for every table yet.
    - We accept "Tight Coupling" to Supabase in Client Components for the sake of speed.

## 7. When to Revisit (Evolution Triggers)

We should move to a full **Domain Model + Mapper** architecture if:

1.  **Data Transformation Complexity**: We spend too much time "cleaning" DB data inside UI components.
2.  **Database Volatility**: We anticipate frequent breaking schema changes that would require massive UI refactors.
3.  **Shared Logic**: We need to share business logic with a non-web client (e.g., Mobile App or Cron Jobs).
4.  **Team Growth**: The team expands beyond 3 developers, necessitating stricter "contracts" between layers.
5.  **Testing Requirements**: We need to perform deep unit testing of business logic without a live database connection.

