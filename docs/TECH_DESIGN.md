# Technical Design Document: AI Accounting Firm

## 1. Architecture Overview
- **Frontend/App Server**: Next.js (App Router) + TypeScript.
- **Database/Auth/Storage**: Supabase.
- **Data Access**: `supabase-js` wrapped in a **Storage Layer** (`storage/`) to decouple UI from DB.
- **Multi-tenancy**: Path-based routing (`/[firmId]/...`) with RLS.
- **AI/Job Processing**: Supabase Database Webhooks -> Edge Functions -> Genkit (Gemini).

## 2. Database Schema Design (PostgreSQL / Supabase)

This schema is designed for multi-tenancy using Row Level Security (RLS) as the primary isolation mechanism. All tables (except `firms`) include a `firm_id` to enforce tenant boundaries.

### 2.1 Tables

#### `firms`
Represents the tenant (Accounting Firm).
*   **id**: `UUID` (Primary Key, Default: `gen_random_uuid()`)
*   **name**: `TEXT` (Not Null)
*   **tax_id**: `TEXT` (Not Null) - (統一編號)
*   **created_at**: `TIMESTAMPTZ` (Default: `now()`)
*   **RLS Policy**:
    *   `SELECT`: Authenticated users can read their own firm OR `auth.jwt() ->> 'role' = 'super_admin'`.
    *   `INSERT`: System admin or initial signup flow only.

#### `profiles`
Public profile table linked 1:1 with Supabase Auth (`auth.users`).
*   **id**: `UUID` (Primary Key, Foreign Key -> `auth.users.id` with `ON DELETE CASCADE`)
*   **firm_id**: `UUID` (Foreign Key -> `firms.id`, Nullable for super admins)
*   **name**: `TEXT`
*   **role**: `TEXT` (Check: `IN ('admin', 'staff', 'super_admin')`, Default: `admin`)
*   **created_at**: `TIMESTAMPTZ` (Default: `now()`)
*   **RLS Policy**:
    *   `SELECT`: Users can read profiles `WHERE firm_id = auth.uid().firm_id` OR `auth.jwt() ->> 'role' = 'super_admin'`.
    *   `UPDATE`: Users can update their own profile.

#### `clients`
The customers of the accounting firm.
*   **id**: `UUID` (Primary Key, Default: `gen_random_uuid()`)
*   **firm_id**: `UUID` (Foreign Key -> `firms.id` with `ON DELETE CASCADE`)
*   **name**: `TEXT` (Not Null)
*   **contact_person**: `TEXT` (負責人姓名)
*   **tax_id**: `TEXT` (Not Null) - (統一編號)
*   **tax_payer_id**: `TEXT` (Not Null) - (稅籍編號)
*   **industry**: `TEXT` (產業描述)
*   **created_at**: `TIMESTAMPTZ` (Default: `now()`)
*   **RLS Policy**:
    *   `ALL`: `firm_id` matches the authenticated user's `firm_id` OR `auth.jwt() ->> 'role' = 'super_admin'`.

#### `invoices`
Represents the uploaded documents (Receipts/Invoices) to be processed.
*   **id**: `UUID` (Primary Key, Default: `gen_random_uuid()`)
*   **firm_id**: `UUID` (Foreign Key -> `firms.id`)
*   **client_id**: `UUID` (Foreign Key -> `clients.id`, Nullable)
*   **storage_path**: `TEXT` (Not Null)
*   **filename**: `TEXT` (Not Null)
*   **in_or_out**: (Check: `IN ('in', 'out')`)
*   **status**: `TEXT` (Check: `IN ('uploaded', 'processing', 'processed', 'confirmed', 'failed')`, Default: `uploaded`)
*   **extracted_data**: `JSONB` (Nullable) - Stores AI-extracted fields (amount, date, tax_id, vendor info, etc.)
*   **uploaded_by**: `UUID` (Foreign Key -> `profiles.id`)
*   **created_at**: `TIMESTAMPTZ` (Default: `now()`)
*   **Status Flow**: `uploaded` → `processing` → `processed` → `confirmed` (or `failed` at any stage)
*   **RLS Policy**:
    *   `ALL`: `firm_id` matches the authenticated user's `firm_id` OR `auth.jwt() ->> 'role' = 'super_admin'`.

### 2.2 User Roles & Permissions

*   **`super_admin`**: Global system administrator (Internal). 
    *   Has full access to all firms, clients, and invoices across the entire platform.
    *   `firm_id` is typically `NULL`.
*   **`admin`**: Firm Manager (Tenant Owner). 
    *   Full access to all data within their specific `firm_id`.
    *   Can manage `staff` profiles within the same firm.
*   **`staff`**: Firm Employee.
    *   Standard access to view, upload, and process data for their `firm_id`.
*   **`client`** (Future): The actual customer of the accounting firm.
    *   Restricted access to view only their own invoices and reports.
    *   Will require a `client_id` link in the `profiles` table.

---

## 3. Data Models & Storage Layer Design

### 3.1 Architectural Decision (Phase 1: Velocity Mode)

**Current Implementation**: We prioritize development speed over strict architectural purity.

- **Services**: Database logic is encapsulated in `lib/services/` for Server Components.
- **Client Fetching**: 
  - We use **SWR** to manage caching and loading states in the UI.
  - **Fetcher**: We use the `supabase-js` client directly inside SWR fetchers. We do **not** create intermediate Server Actions just for reading data unless complex security logic is required.
  - *Tradeoff*: This couples the UI to Supabase but allows for rapid iteration and Realtime features.
- **Types**: We use types generated by the Supabase CLI (`database.types.ts`) directly.
- **Validation**: Zod is used strictly for **Inbound** traffic (Forms and Server Action inputs).

The **Repository/DAO Pattern** and **Domain Models** described below represent our **Target Architecture**. We will transition to this structure once the project hits the "Evolution Triggers" defined in `docs/DATA_VALIDATION_AND_TYPES.md`.

### 3.2 Directory Structure (Phase 1: Velocity)
```
lib/
  services/     # Business Logic & DB Calls (for Server Components)
    firm.ts
    client.ts
    invoice.ts
  supabase/     # Supabase connection setup
    client.ts
    server.ts
```

### 3.3 Directory Structure (Target / Future)
```
lib/
  domain/       # Pure TypeScript Interfaces (The Contract)
    models.ts   # Zod schemas & Type Definitions
    api.ts      # Zod schemas for APIs
  storage/      # The Implementation Layer (Repository Pattern)
    types.ts    # Storage interface definitions
    supabase/   # Supabase-specific implementation
    index.ts    # Exports the specific implementation
```

### 3.3 Domain Models (`lib/domain/models.ts`)
These schemas define the shape and validation rules for data used by the UI. They do **not** depend on Supabase types.

```typescript
import { z } from 'zod';

export const profileSchema = z.object({
  id: z.string().uuid(),
  firmId: z.string().uuid().optional(),
  name: z.string(),
  role: z.enum(['admin', 'staff', 'super_admin']),
});
export type Profile = z.infer<typeof profileSchema>;

export const firmSchema = z.object({
  id: z.string().uuid(),
  businessName: z.string(), // 營業人名稱
  taxId: z.string(), // 統一編號
});
export type Firm = z.infer<typeof firmSchema>;

export const clientSchema = z.object({
  id: z.string().uuid(),
  firmId: z.string().uuid(),
  businessName: z.string(), // 營業人名稱
  taxId: z.string(), // 統一編號
  taxPayerId: z.string(), // 稅籍編號
  industry: z.string().optional(), // 產業描述
});
export type Client = z.infer<typeof clientSchema>;

export const invoiceSchema = z.object({
  id: z.string().uuid(),
  firmId: z.string().uuid(),
  clientId: z.string().uuid().optional(),
  filename: z.string(),
  storagePath: z.string(),
  status: z.enum(['uploaded', 'processing', 'processed', 'confirmed', 'failed']),
  extractedData: z.record(z.unknown()).nullable().optional(), // JSONB field for AI-extracted data
  uploadedBy: z.string().uuid(),
  createdAt: z.date(),
});
export type Invoice = z.infer<typeof invoiceSchema>;
```

### 3.4 Storage Layer Interface (`storage/types.ts`)
This defines *how* the application talks to the data layer.

```typescript
import { Client, Invoice, Profile } from '@/domain/models';

export interface InvoiceStorage {
  upload(file: File, firmId: string, userId: string): Promise<Invoice>;
  list(firmId: string): Promise<Invoice[]>;
  get(id: string): Promise<Invoice | null>;
  updateStatus(id: string, status: Invoice['status']): Promise<void>;
}

export interface ClientStorage {
  create(firmId: string, data: Partial<Client>): Promise<Client>;
  list(firmId: string): Promise<Client[]>;
}

export interface ProfileStorage {
  getProfile(userId: string): Promise<Profile | null>;
}
```

### 3.5 Supabase Implementation (`storage/supabase/invoice.ts`)
The concrete implementation using `supabase-js`. It uses the clients from `lib/supabase/`.

```typescript
import { InvoiceStorage } from '../types';
import { createClient } from '@/lib/supabase/server';
import { Invoice } from '@/domain/models';

export const supabaseInvoiceStorage: InvoiceStorage = {
  async list(firmId: string): Promise<Invoice[]> {
    const supabase = await createClient();
    const { data, error } = await supabase
      .from('invoices')
      .select('*')
      .eq('firm_id', firmId);
      
    if (error) throw error;
    
    // Mapper: DB Snake_case -> Domain CamelCase
    return data.map(row => ({
      id: row.id,
      firmId: row.firm_id,
      clientId: row.client_id,
      filename: row.filename,
      storagePath: row.storage_path,
      status: row.status,
      uploadedBy: row.uploaded_by,
      createdAt: row.created_at
    }));
  },
  
  // ... implement upload, get, updateStatus similarly
};
```


### 3.6 Usage in UI Components
The UI never imports `supabase-js` directly for data fetching.

```tsx
import { invoiceStorage } from '@/storage';

export default async function InvoiceList({ params }: { params: { firmId: string } }) {
  // If we switch to Prisma later, we only change the import in @/storage/index.ts
  const invoices = await invoiceStorage.list(params.firmId);
  
  return (
    <ul>
      {invoices.map(inv => <li key={inv.id}>{inv.filename}</li>)}
    </ul>
  );
}
```

## 4. Authentication & Onboarding Flow

Given the focus on Firm Signup/Signin (no client login yet):

### 4.1 Firm Signup (Onboarding)
1.  **User Registration**: User signs up via Supabase Auth (Email/Password or OAuth).
2.  **Profile Creation**:
    *   Trigger: `INSERT ON auth.users` (Supabase Trigger) OR Manual Step after signup.
    *   Action: Create row in `profiles` table.
3.  **Firm Creation**:
    *   UI: "Create your Firm" form.
    *   Action: Insert into `firms`.
    *   Link: Update the current `profiles` row with the new `firm_id` and set role to `admin`.

### 4.2 Firm Signin
1.  **Login**: User authenticates.
2.  **Routing**:
    *   Fetch `firm_id` from `profiles` table.
    *   If `firm_id` exists: Redirect to `/[firmId]/dashboard`.
    *   If `firm_id` is null: Redirect to `/onboarding` (Create Firm).

```